// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: account.proto

#include "account.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr AccountInfo::AccountInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : broker_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , account_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , trading_day_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , currency_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , biz_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pre_mortgage_(0)
  , pre_credit_(0)
  , pre_deposit_(0)
  , pre_balance_(0)
  , pre_margin_(0)
  , interest_base_(0)
  , interest_(0)
  , deposit_(0)
  , withdraw_(0)
  , frozen_margin_(0)
  , frozen_cash_(0)
  , frozen_commission_(0)
  , curr_margin_(0)
  , cash_in_(0)
  , commission_(0)
  , close_profit_(0)
  , position_profit_(0)
  , balance_(0)
  , available_(0)
  , withdraw_quota_(0)
  , reserve_(0)
  , credit_(0)
  , mortgage_(0)
  , exchange_margin_(0)
  , delivery_margin_(0)
  , exchange_delivery_margin_(0)
  , reserve_balance_(0)
  , pre_fund_mortgage_in_(0)
  , pre_fund_mortgage_out_(0)
  , fund_mortgage_in_(0)
  , fund_mortgage_out_(0)
  , fund_mortgage_available_(0)
  , mortgageable_fund_(0)
  , spec_product_margin_(0)
  , spec_product_frozen_margin_(0)
  , spec_product_commission_(0)
  , spec_product_frozen_commission_(0)
  , spec_product_position_profit_(0)
  , spec_product_close_profit_(0)
  , spec_product_position_profit_by_alg_(0)
  , spec_product_exchange_margin_(0)
  , frozen_swap_(0)
  , remain_swap_(0)
  , settlement_id_(0){}
struct AccountInfoDefaultTypeInternal {
  constexpr AccountInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AccountInfoDefaultTypeInternal() {}
  union {
    AccountInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AccountInfoDefaultTypeInternal _AccountInfo_default_instance_;
constexpr Position::Position(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reserve1_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , broker_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , investor_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , posi_direction_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hedge_flag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_date_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , exchange_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , instrument_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , instrument_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_(0)
  , yd_position_(0)
  , today_position_(0)
  , open_volume_(0)
  , open_amount_(0)
  , close_amount_(0)
  , position_cost_(0)
  , close_volume_(0)
  , long_frozen_(0)
  , close_profit_(0)
  , position_profit_(0)
  , open_cost_(0)
  , long_frozen_amount_(0)
  , short_frozen_amount_(0)
  , pre_margin_(0)
  , use_margin_(0)
  , frozen_margin_(0)
  , frozen_cash_(0)
  , short_frozen_(0)
  , settlement_id_(0)
  , frozen_commission_(0)
  , cash_in_(0)
  , commission_(0)
  , pre_settlement_price_(0)
  , settlement_price_(0)
  , exchange_margin_(0)
  , comb_position_(0)
  , comb_long_frozen_(0)
  , close_profit_by_date_(0)
  , comb_short_frozen_(0)
  , strike_frozen_(0)
  , close_profit_by_trade_(0)
  , strike_frozen_amount_(0)
  , abandon_frozen_(0)
  , yd_strike_frozen_(0)
  , position_cost_offset_(0){}
struct PositionDefaultTypeInternal {
  constexpr PositionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PositionDefaultTypeInternal _Position_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_account_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_account_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_account_2eproto = nullptr;

const uint32_t TableStruct_account_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AccountInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AccountInfo, broker_id_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, account_id_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_mortgage_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_credit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_deposit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_balance_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, interest_base_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, interest_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, deposit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, withdraw_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, frozen_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, frozen_cash_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, frozen_commission_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, curr_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, cash_in_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, commission_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, close_profit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, position_profit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, balance_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, available_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, withdraw_quota_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, reserve_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, trading_day_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, settlement_id_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, credit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, mortgage_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, exchange_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, delivery_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, exchange_delivery_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, reserve_balance_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, currency_id_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_fund_mortgage_in_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, pre_fund_mortgage_out_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, fund_mortgage_in_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, fund_mortgage_out_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, fund_mortgage_available_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, mortgageable_fund_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_frozen_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_commission_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_frozen_commission_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_position_profit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_close_profit_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_position_profit_by_alg_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, spec_product_exchange_margin_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, biz_type_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, frozen_swap_),
  PROTOBUF_FIELD_OFFSET(::AccountInfo, remain_swap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Position, reserve1_),
  PROTOBUF_FIELD_OFFSET(::Position, broker_id_),
  PROTOBUF_FIELD_OFFSET(::Position, investor_id_),
  PROTOBUF_FIELD_OFFSET(::Position, posi_direction_),
  PROTOBUF_FIELD_OFFSET(::Position, hedge_flag_),
  PROTOBUF_FIELD_OFFSET(::Position, position_date_),
  PROTOBUF_FIELD_OFFSET(::Position, position_),
  PROTOBUF_FIELD_OFFSET(::Position, yd_position_),
  PROTOBUF_FIELD_OFFSET(::Position, today_position_),
  PROTOBUF_FIELD_OFFSET(::Position, open_volume_),
  PROTOBUF_FIELD_OFFSET(::Position, close_volume_),
  PROTOBUF_FIELD_OFFSET(::Position, open_amount_),
  PROTOBUF_FIELD_OFFSET(::Position, close_amount_),
  PROTOBUF_FIELD_OFFSET(::Position, position_cost_),
  PROTOBUF_FIELD_OFFSET(::Position, close_profit_),
  PROTOBUF_FIELD_OFFSET(::Position, position_profit_),
  PROTOBUF_FIELD_OFFSET(::Position, open_cost_),
  PROTOBUF_FIELD_OFFSET(::Position, long_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, short_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, long_frozen_amount_),
  PROTOBUF_FIELD_OFFSET(::Position, short_frozen_amount_),
  PROTOBUF_FIELD_OFFSET(::Position, pre_margin_),
  PROTOBUF_FIELD_OFFSET(::Position, use_margin_),
  PROTOBUF_FIELD_OFFSET(::Position, frozen_margin_),
  PROTOBUF_FIELD_OFFSET(::Position, frozen_cash_),
  PROTOBUF_FIELD_OFFSET(::Position, frozen_commission_),
  PROTOBUF_FIELD_OFFSET(::Position, cash_in_),
  PROTOBUF_FIELD_OFFSET(::Position, commission_),
  PROTOBUF_FIELD_OFFSET(::Position, pre_settlement_price_),
  PROTOBUF_FIELD_OFFSET(::Position, settlement_price_),
  PROTOBUF_FIELD_OFFSET(::Position, settlement_id_),
  PROTOBUF_FIELD_OFFSET(::Position, exchange_margin_),
  PROTOBUF_FIELD_OFFSET(::Position, comb_position_),
  PROTOBUF_FIELD_OFFSET(::Position, comb_long_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, comb_short_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, close_profit_by_date_),
  PROTOBUF_FIELD_OFFSET(::Position, close_profit_by_trade_),
  PROTOBUF_FIELD_OFFSET(::Position, strike_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, strike_frozen_amount_),
  PROTOBUF_FIELD_OFFSET(::Position, abandon_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, exchange_id_),
  PROTOBUF_FIELD_OFFSET(::Position, yd_strike_frozen_),
  PROTOBUF_FIELD_OFFSET(::Position, position_cost_offset_),
  PROTOBUF_FIELD_OFFSET(::Position, instrument_id_),
  PROTOBUF_FIELD_OFFSET(::Position, instrument_name_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::AccountInfo)},
  { 55, -1, -1, sizeof(::Position)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AccountInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Position_default_instance_),
};

const char descriptor_table_protodef_account_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\raccount.proto\"\305\t\n\013AccountInfo\022\021\n\tbroke"
  "r_id\030\001 \001(\t\022\022\n\naccount_id\030\002 \001(\t\022\024\n\014pre_mo"
  "rtgage\030\003 \001(\001\022\022\n\npre_credit\030\004 \001(\001\022\023\n\013pre_"
  "deposit\030\005 \001(\001\022\023\n\013pre_balance\030\006 \001(\001\022\022\n\npr"
  "e_margin\030\007 \001(\001\022\025\n\rinterest_base\030\010 \001(\001\022\020\n"
  "\010interest\030\t \001(\001\022\017\n\007deposit\030\n \001(\001\022\020\n\010with"
  "draw\030\013 \001(\001\022\025\n\rfrozen_margin\030\014 \001(\001\022\023\n\013fro"
  "zen_cash\030\r \001(\001\022\031\n\021frozen_commission\030\016 \001("
  "\001\022\023\n\013curr_margin\030\017 \001(\001\022\017\n\007cash_in\030\020 \001(\001\022"
  "\022\n\ncommission\030\021 \001(\001\022\024\n\014close_profit\030\022 \001("
  "\001\022\027\n\017position_profit\030\023 \001(\001\022\017\n\007balance\030\024 "
  "\001(\001\022\021\n\tavailable\030\025 \001(\001\022\026\n\016withdraw_quota"
  "\030\026 \001(\001\022\017\n\007reserve\030\027 \001(\001\022\023\n\013trading_day\030\030"
  " \001(\t\022\025\n\rsettlement_id\030\031 \001(\005\022\016\n\006credit\030\032 "
  "\001(\001\022\020\n\010mortgage\030\033 \001(\001\022\027\n\017exchange_margin"
  "\030\034 \001(\001\022\027\n\017delivery_margin\030\035 \001(\001\022 \n\030excha"
  "nge_delivery_margin\030\036 \001(\001\022\027\n\017reserve_bal"
  "ance\030\037 \001(\001\022\023\n\013currency_id\030  \001(\t\022\034\n\024pre_f"
  "und_mortgage_in\030! \001(\001\022\035\n\025pre_fund_mortga"
  "ge_out\030\" \001(\001\022\030\n\020fund_mortgage_in\030# \001(\001\022\031"
  "\n\021fund_mortgage_out\030$ \001(\001\022\037\n\027fund_mortga"
  "ge_available\030% \001(\001\022\031\n\021mortgageable_fund\030"
  "& \001(\001\022\033\n\023spec_product_margin\030\' \001(\001\022\"\n\032sp"
  "ec_product_frozen_margin\030( \001(\001\022\037\n\027spec_p"
  "roduct_commission\030) \001(\001\022&\n\036spec_product_"
  "frozen_commission\030* \001(\001\022$\n\034spec_product_"
  "position_profit\030+ \001(\001\022!\n\031spec_product_cl"
  "ose_profit\030, \001(\001\022+\n#spec_product_positio"
  "n_profit_by_alg\030- \001(\001\022$\n\034spec_product_ex"
  "change_margin\030. \001(\001\022\020\n\010biz_type\030/ \001(\t\022\023\n"
  "\013frozen_swap\0300 \001(\001\022\023\n\013remain_swap\0301 \001(\001\""
  "\250\010\n\010Position\022\020\n\010reserve1\030\001 \001(\t\022\021\n\tbroker"
  "_id\030\002 \001(\t\022\023\n\013investor_id\030\003 \001(\t\022\026\n\016posi_d"
  "irection\030\004 \001(\t\022\022\n\nhedge_flag\030\005 \001(\t\022\025\n\rpo"
  "sition_date\030\006 \001(\t\022\020\n\010position\030\007 \001(\005\022\023\n\013y"
  "d_position\030\010 \001(\005\022\026\n\016today_position\030\t \001(\005"
  "\022\023\n\013open_volume\030\n \001(\005\022\024\n\014close_volume\030\013 "
  "\001(\005\022\023\n\013open_amount\030\014 \001(\001\022\024\n\014close_amount"
  "\030\r \001(\001\022\025\n\rposition_cost\030\016 \001(\001\022\024\n\014close_p"
  "rofit\030\017 \001(\001\022\027\n\017position_profit\030\020 \001(\001\022\021\n\t"
  "open_cost\030\021 \001(\001\022\023\n\013long_frozen\030\022 \001(\005\022\024\n\014"
  "short_frozen\030\023 \001(\005\022\032\n\022long_frozen_amount"
  "\030\024 \001(\001\022\033\n\023short_frozen_amount\030\025 \001(\001\022\022\n\np"
  "re_margin\030\026 \001(\001\022\022\n\nuse_margin\030\027 \001(\001\022\025\n\rf"
  "rozen_margin\030\030 \001(\001\022\023\n\013frozen_cash\030\031 \001(\001\022"
  "\031\n\021frozen_commission\030\032 \001(\001\022\017\n\007cash_in\030\033 "
  "\001(\001\022\022\n\ncommission\030\034 \001(\001\022\034\n\024pre_settlemen"
  "t_price\030\035 \001(\001\022\030\n\020settlement_price\030\036 \001(\001\022"
  "\025\n\rsettlement_id\030\037 \001(\005\022\027\n\017exchange_margi"
  "n\030  \001(\001\022\025\n\rcomb_position\030! \001(\005\022\030\n\020comb_l"
  "ong_frozen\030\" \001(\005\022\031\n\021comb_short_frozen\030# "
  "\001(\005\022\034\n\024close_profit_by_date\030$ \001(\001\022\035\n\025clo"
  "se_profit_by_trade\030% \001(\001\022\025\n\rstrike_froze"
  "n\030& \001(\005\022\034\n\024strike_frozen_amount\030\' \001(\001\022\026\n"
  "\016abandon_frozen\030( \001(\005\022\023\n\013exchange_id\030) \001"
  "(\t\022\030\n\020yd_strike_frozen\030* \001(\005\022\034\n\024position"
  "_cost_offset\030+ \001(\001\022\025\n\rinstrument_id\030, \001("
  "\t\022\027\n\017instrument_name\030- \001(\tB\"Z github.com"
  "/crazy-choose/pb/modelb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_account_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_account_2eproto = {
  false, false, 2350, descriptor_table_protodef_account_2eproto, "account.proto", 
  &descriptor_table_account_2eproto_once, nullptr, 0, 2,
  schemas, file_default_instances, TableStruct_account_2eproto::offsets,
  file_level_metadata_account_2eproto, file_level_enum_descriptors_account_2eproto, file_level_service_descriptors_account_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_account_2eproto_getter() {
  return &descriptor_table_account_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_account_2eproto(&descriptor_table_account_2eproto);

// ===================================================================

class AccountInfo::_Internal {
 public:
};

AccountInfo::AccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AccountInfo)
}
AccountInfo::AccountInfo(const AccountInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  broker_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    broker_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_broker_id().empty()) {
    broker_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_broker_id(), 
      GetArenaForAllocation());
  }
  account_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    account_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_id().empty()) {
    account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_account_id(), 
      GetArenaForAllocation());
  }
  trading_day_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trading_day_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_trading_day().empty()) {
    trading_day_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_trading_day(), 
      GetArenaForAllocation());
  }
  currency_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    currency_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_currency_id().empty()) {
    currency_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_currency_id(), 
      GetArenaForAllocation());
  }
  biz_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    biz_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_biz_type().empty()) {
    biz_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_biz_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pre_mortgage_, &from.pre_mortgage_,
    static_cast<size_t>(reinterpret_cast<char*>(&settlement_id_) -
    reinterpret_cast<char*>(&pre_mortgage_)) + sizeof(settlement_id_));
  // @@protoc_insertion_point(copy_constructor:AccountInfo)
}

inline void AccountInfo::SharedCtor() {
broker_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  broker_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
account_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  account_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trading_day_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trading_day_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
currency_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  currency_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
biz_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  biz_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pre_mortgage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&settlement_id_) -
    reinterpret_cast<char*>(&pre_mortgage_)) + sizeof(settlement_id_));
}

AccountInfo::~AccountInfo() {
  // @@protoc_insertion_point(destructor:AccountInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AccountInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  broker_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  account_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  trading_day_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  currency_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  biz_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AccountInfo::ArenaDtor(void* object) {
  AccountInfo* _this = reinterpret_cast< AccountInfo* >(object);
  (void)_this;
}
void AccountInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AccountInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AccountInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:AccountInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  broker_id_.ClearToEmpty();
  account_id_.ClearToEmpty();
  trading_day_.ClearToEmpty();
  currency_id_.ClearToEmpty();
  biz_type_.ClearToEmpty();
  ::memset(&pre_mortgage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&settlement_id_) -
      reinterpret_cast<char*>(&pre_mortgage_)) + sizeof(settlement_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string broker_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_broker_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AccountInfo.broker_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string account_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AccountInfo.account_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double pre_mortgage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          pre_mortgage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_credit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          pre_credit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_deposit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          pre_deposit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_balance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          pre_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_margin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          pre_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double interest_base = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          interest_base_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double interest = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          interest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double deposit = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          deposit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double withdraw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          withdraw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_margin = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          frozen_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_cash = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          frozen_cash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_commission = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          frozen_commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double curr_margin = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          curr_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cash_in = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          cash_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double commission = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double close_profit = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          close_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double position_profit = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          position_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double balance = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double available = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double withdraw_quota = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          withdraw_quota_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reserve = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          reserve_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string trading_day = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_trading_day();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AccountInfo.trading_day"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 settlement_id = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          settlement_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double credit = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          credit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double mortgage = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          mortgage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double exchange_margin = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 225)) {
          exchange_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double delivery_margin = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          delivery_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double exchange_delivery_margin = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          exchange_delivery_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reserve_balance = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          reserve_balance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string currency_id = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_currency_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AccountInfo.currency_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double pre_fund_mortgage_in = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          pre_fund_mortgage_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_fund_mortgage_out = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          pre_fund_mortgage_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fund_mortgage_in = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          fund_mortgage_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fund_mortgage_out = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          fund_mortgage_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fund_mortgage_available = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          fund_mortgage_available_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double mortgageable_fund = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          mortgageable_fund_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_margin = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          spec_product_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_frozen_margin = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          spec_product_frozen_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_commission = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          spec_product_commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_frozen_commission = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          spec_product_frozen_commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_position_profit = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          spec_product_position_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_close_profit = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          spec_product_close_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_position_profit_by_alg = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          spec_product_position_profit_by_alg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spec_product_exchange_margin = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          spec_product_exchange_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string biz_type = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_biz_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AccountInfo.biz_type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double frozen_swap = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          frozen_swap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double remain_swap = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          remain_swap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccountInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AccountInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string broker_id = 1;
  if (!this->_internal_broker_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_broker_id().data(), static_cast<int>(this->_internal_broker_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AccountInfo.broker_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_broker_id(), target);
  }

  // string account_id = 2;
  if (!this->_internal_account_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_account_id().data(), static_cast<int>(this->_internal_account_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AccountInfo.account_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_id(), target);
  }

  // double pre_mortgage = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_mortgage = this->_internal_pre_mortgage();
  uint64_t raw_pre_mortgage;
  memcpy(&raw_pre_mortgage, &tmp_pre_mortgage, sizeof(tmp_pre_mortgage));
  if (raw_pre_mortgage != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_pre_mortgage(), target);
  }

  // double pre_credit = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_credit = this->_internal_pre_credit();
  uint64_t raw_pre_credit;
  memcpy(&raw_pre_credit, &tmp_pre_credit, sizeof(tmp_pre_credit));
  if (raw_pre_credit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_pre_credit(), target);
  }

  // double pre_deposit = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_deposit = this->_internal_pre_deposit();
  uint64_t raw_pre_deposit;
  memcpy(&raw_pre_deposit, &tmp_pre_deposit, sizeof(tmp_pre_deposit));
  if (raw_pre_deposit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_pre_deposit(), target);
  }

  // double pre_balance = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_balance = this->_internal_pre_balance();
  uint64_t raw_pre_balance;
  memcpy(&raw_pre_balance, &tmp_pre_balance, sizeof(tmp_pre_balance));
  if (raw_pre_balance != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_pre_balance(), target);
  }

  // double pre_margin = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = this->_internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_pre_margin(), target);
  }

  // double interest_base = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest_base = this->_internal_interest_base();
  uint64_t raw_interest_base;
  memcpy(&raw_interest_base, &tmp_interest_base, sizeof(tmp_interest_base));
  if (raw_interest_base != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_interest_base(), target);
  }

  // double interest = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest = this->_internal_interest();
  uint64_t raw_interest;
  memcpy(&raw_interest, &tmp_interest, sizeof(tmp_interest));
  if (raw_interest != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_interest(), target);
  }

  // double deposit = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deposit = this->_internal_deposit();
  uint64_t raw_deposit;
  memcpy(&raw_deposit, &tmp_deposit, sizeof(tmp_deposit));
  if (raw_deposit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_deposit(), target);
  }

  // double withdraw = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw = this->_internal_withdraw();
  uint64_t raw_withdraw;
  memcpy(&raw_withdraw, &tmp_withdraw, sizeof(tmp_withdraw));
  if (raw_withdraw != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_withdraw(), target);
  }

  // double frozen_margin = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = this->_internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_frozen_margin(), target);
  }

  // double frozen_cash = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = this->_internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_frozen_cash(), target);
  }

  // double frozen_commission = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = this->_internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_frozen_commission(), target);
  }

  // double curr_margin = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_margin = this->_internal_curr_margin();
  uint64_t raw_curr_margin;
  memcpy(&raw_curr_margin, &tmp_curr_margin, sizeof(tmp_curr_margin));
  if (raw_curr_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(15, this->_internal_curr_margin(), target);
  }

  // double cash_in = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = this->_internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(16, this->_internal_cash_in(), target);
  }

  // double commission = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = this->_internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(17, this->_internal_commission(), target);
  }

  // double close_profit = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = this->_internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(18, this->_internal_close_profit(), target);
  }

  // double position_profit = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = this->_internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(19, this->_internal_position_profit(), target);
  }

  // double balance = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_balance = this->_internal_balance();
  uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(20, this->_internal_balance(), target);
  }

  // double available = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_available = this->_internal_available();
  uint64_t raw_available;
  memcpy(&raw_available, &tmp_available, sizeof(tmp_available));
  if (raw_available != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_available(), target);
  }

  // double withdraw_quota = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw_quota = this->_internal_withdraw_quota();
  uint64_t raw_withdraw_quota;
  memcpy(&raw_withdraw_quota, &tmp_withdraw_quota, sizeof(tmp_withdraw_quota));
  if (raw_withdraw_quota != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(22, this->_internal_withdraw_quota(), target);
  }

  // double reserve = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve = this->_internal_reserve();
  uint64_t raw_reserve;
  memcpy(&raw_reserve, &tmp_reserve, sizeof(tmp_reserve));
  if (raw_reserve != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(23, this->_internal_reserve(), target);
  }

  // string trading_day = 24;
  if (!this->_internal_trading_day().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_trading_day().data(), static_cast<int>(this->_internal_trading_day().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AccountInfo.trading_day");
    target = stream->WriteStringMaybeAliased(
        24, this->_internal_trading_day(), target);
  }

  // int32 settlement_id = 25;
  if (this->_internal_settlement_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(25, this->_internal_settlement_id(), target);
  }

  // double credit = 26;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_credit = this->_internal_credit();
  uint64_t raw_credit;
  memcpy(&raw_credit, &tmp_credit, sizeof(tmp_credit));
  if (raw_credit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(26, this->_internal_credit(), target);
  }

  // double mortgage = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgage = this->_internal_mortgage();
  uint64_t raw_mortgage;
  memcpy(&raw_mortgage, &tmp_mortgage, sizeof(tmp_mortgage));
  if (raw_mortgage != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(27, this->_internal_mortgage(), target);
  }

  // double exchange_margin = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = this->_internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(28, this->_internal_exchange_margin(), target);
  }

  // double delivery_margin = 29;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delivery_margin = this->_internal_delivery_margin();
  uint64_t raw_delivery_margin;
  memcpy(&raw_delivery_margin, &tmp_delivery_margin, sizeof(tmp_delivery_margin));
  if (raw_delivery_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(29, this->_internal_delivery_margin(), target);
  }

  // double exchange_delivery_margin = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_delivery_margin = this->_internal_exchange_delivery_margin();
  uint64_t raw_exchange_delivery_margin;
  memcpy(&raw_exchange_delivery_margin, &tmp_exchange_delivery_margin, sizeof(tmp_exchange_delivery_margin));
  if (raw_exchange_delivery_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(30, this->_internal_exchange_delivery_margin(), target);
  }

  // double reserve_balance = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve_balance = this->_internal_reserve_balance();
  uint64_t raw_reserve_balance;
  memcpy(&raw_reserve_balance, &tmp_reserve_balance, sizeof(tmp_reserve_balance));
  if (raw_reserve_balance != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(31, this->_internal_reserve_balance(), target);
  }

  // string currency_id = 32;
  if (!this->_internal_currency_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_currency_id().data(), static_cast<int>(this->_internal_currency_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AccountInfo.currency_id");
    target = stream->WriteStringMaybeAliased(
        32, this->_internal_currency_id(), target);
  }

  // double pre_fund_mortgage_in = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_in = this->_internal_pre_fund_mortgage_in();
  uint64_t raw_pre_fund_mortgage_in;
  memcpy(&raw_pre_fund_mortgage_in, &tmp_pre_fund_mortgage_in, sizeof(tmp_pre_fund_mortgage_in));
  if (raw_pre_fund_mortgage_in != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(33, this->_internal_pre_fund_mortgage_in(), target);
  }

  // double pre_fund_mortgage_out = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_out = this->_internal_pre_fund_mortgage_out();
  uint64_t raw_pre_fund_mortgage_out;
  memcpy(&raw_pre_fund_mortgage_out, &tmp_pre_fund_mortgage_out, sizeof(tmp_pre_fund_mortgage_out));
  if (raw_pre_fund_mortgage_out != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(34, this->_internal_pre_fund_mortgage_out(), target);
  }

  // double fund_mortgage_in = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_in = this->_internal_fund_mortgage_in();
  uint64_t raw_fund_mortgage_in;
  memcpy(&raw_fund_mortgage_in, &tmp_fund_mortgage_in, sizeof(tmp_fund_mortgage_in));
  if (raw_fund_mortgage_in != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(35, this->_internal_fund_mortgage_in(), target);
  }

  // double fund_mortgage_out = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_out = this->_internal_fund_mortgage_out();
  uint64_t raw_fund_mortgage_out;
  memcpy(&raw_fund_mortgage_out, &tmp_fund_mortgage_out, sizeof(tmp_fund_mortgage_out));
  if (raw_fund_mortgage_out != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(36, this->_internal_fund_mortgage_out(), target);
  }

  // double fund_mortgage_available = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_available = this->_internal_fund_mortgage_available();
  uint64_t raw_fund_mortgage_available;
  memcpy(&raw_fund_mortgage_available, &tmp_fund_mortgage_available, sizeof(tmp_fund_mortgage_available));
  if (raw_fund_mortgage_available != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(37, this->_internal_fund_mortgage_available(), target);
  }

  // double mortgageable_fund = 38;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgageable_fund = this->_internal_mortgageable_fund();
  uint64_t raw_mortgageable_fund;
  memcpy(&raw_mortgageable_fund, &tmp_mortgageable_fund, sizeof(tmp_mortgageable_fund));
  if (raw_mortgageable_fund != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(38, this->_internal_mortgageable_fund(), target);
  }

  // double spec_product_margin = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_margin = this->_internal_spec_product_margin();
  uint64_t raw_spec_product_margin;
  memcpy(&raw_spec_product_margin, &tmp_spec_product_margin, sizeof(tmp_spec_product_margin));
  if (raw_spec_product_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(39, this->_internal_spec_product_margin(), target);
  }

  // double spec_product_frozen_margin = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_margin = this->_internal_spec_product_frozen_margin();
  uint64_t raw_spec_product_frozen_margin;
  memcpy(&raw_spec_product_frozen_margin, &tmp_spec_product_frozen_margin, sizeof(tmp_spec_product_frozen_margin));
  if (raw_spec_product_frozen_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(40, this->_internal_spec_product_frozen_margin(), target);
  }

  // double spec_product_commission = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_commission = this->_internal_spec_product_commission();
  uint64_t raw_spec_product_commission;
  memcpy(&raw_spec_product_commission, &tmp_spec_product_commission, sizeof(tmp_spec_product_commission));
  if (raw_spec_product_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(41, this->_internal_spec_product_commission(), target);
  }

  // double spec_product_frozen_commission = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_commission = this->_internal_spec_product_frozen_commission();
  uint64_t raw_spec_product_frozen_commission;
  memcpy(&raw_spec_product_frozen_commission, &tmp_spec_product_frozen_commission, sizeof(tmp_spec_product_frozen_commission));
  if (raw_spec_product_frozen_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(42, this->_internal_spec_product_frozen_commission(), target);
  }

  // double spec_product_position_profit = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit = this->_internal_spec_product_position_profit();
  uint64_t raw_spec_product_position_profit;
  memcpy(&raw_spec_product_position_profit, &tmp_spec_product_position_profit, sizeof(tmp_spec_product_position_profit));
  if (raw_spec_product_position_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(43, this->_internal_spec_product_position_profit(), target);
  }

  // double spec_product_close_profit = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_close_profit = this->_internal_spec_product_close_profit();
  uint64_t raw_spec_product_close_profit;
  memcpy(&raw_spec_product_close_profit, &tmp_spec_product_close_profit, sizeof(tmp_spec_product_close_profit));
  if (raw_spec_product_close_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(44, this->_internal_spec_product_close_profit(), target);
  }

  // double spec_product_position_profit_by_alg = 45;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit_by_alg = this->_internal_spec_product_position_profit_by_alg();
  uint64_t raw_spec_product_position_profit_by_alg;
  memcpy(&raw_spec_product_position_profit_by_alg, &tmp_spec_product_position_profit_by_alg, sizeof(tmp_spec_product_position_profit_by_alg));
  if (raw_spec_product_position_profit_by_alg != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(45, this->_internal_spec_product_position_profit_by_alg(), target);
  }

  // double spec_product_exchange_margin = 46;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_exchange_margin = this->_internal_spec_product_exchange_margin();
  uint64_t raw_spec_product_exchange_margin;
  memcpy(&raw_spec_product_exchange_margin, &tmp_spec_product_exchange_margin, sizeof(tmp_spec_product_exchange_margin));
  if (raw_spec_product_exchange_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(46, this->_internal_spec_product_exchange_margin(), target);
  }

  // string biz_type = 47;
  if (!this->_internal_biz_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_biz_type().data(), static_cast<int>(this->_internal_biz_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AccountInfo.biz_type");
    target = stream->WriteStringMaybeAliased(
        47, this->_internal_biz_type(), target);
  }

  // double frozen_swap = 48;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_swap = this->_internal_frozen_swap();
  uint64_t raw_frozen_swap;
  memcpy(&raw_frozen_swap, &tmp_frozen_swap, sizeof(tmp_frozen_swap));
  if (raw_frozen_swap != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(48, this->_internal_frozen_swap(), target);
  }

  // double remain_swap = 49;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_remain_swap = this->_internal_remain_swap();
  uint64_t raw_remain_swap;
  memcpy(&raw_remain_swap, &tmp_remain_swap, sizeof(tmp_remain_swap));
  if (raw_remain_swap != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(49, this->_internal_remain_swap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AccountInfo)
  return target;
}

size_t AccountInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AccountInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string broker_id = 1;
  if (!this->_internal_broker_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_broker_id());
  }

  // string account_id = 2;
  if (!this->_internal_account_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_id());
  }

  // string trading_day = 24;
  if (!this->_internal_trading_day().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_trading_day());
  }

  // string currency_id = 32;
  if (!this->_internal_currency_id().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_currency_id());
  }

  // string biz_type = 47;
  if (!this->_internal_biz_type().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_biz_type());
  }

  // double pre_mortgage = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_mortgage = this->_internal_pre_mortgage();
  uint64_t raw_pre_mortgage;
  memcpy(&raw_pre_mortgage, &tmp_pre_mortgage, sizeof(tmp_pre_mortgage));
  if (raw_pre_mortgage != 0) {
    total_size += 1 + 8;
  }

  // double pre_credit = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_credit = this->_internal_pre_credit();
  uint64_t raw_pre_credit;
  memcpy(&raw_pre_credit, &tmp_pre_credit, sizeof(tmp_pre_credit));
  if (raw_pre_credit != 0) {
    total_size += 1 + 8;
  }

  // double pre_deposit = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_deposit = this->_internal_pre_deposit();
  uint64_t raw_pre_deposit;
  memcpy(&raw_pre_deposit, &tmp_pre_deposit, sizeof(tmp_pre_deposit));
  if (raw_pre_deposit != 0) {
    total_size += 1 + 8;
  }

  // double pre_balance = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_balance = this->_internal_pre_balance();
  uint64_t raw_pre_balance;
  memcpy(&raw_pre_balance, &tmp_pre_balance, sizeof(tmp_pre_balance));
  if (raw_pre_balance != 0) {
    total_size += 1 + 8;
  }

  // double pre_margin = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = this->_internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    total_size += 1 + 8;
  }

  // double interest_base = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest_base = this->_internal_interest_base();
  uint64_t raw_interest_base;
  memcpy(&raw_interest_base, &tmp_interest_base, sizeof(tmp_interest_base));
  if (raw_interest_base != 0) {
    total_size += 1 + 8;
  }

  // double interest = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest = this->_internal_interest();
  uint64_t raw_interest;
  memcpy(&raw_interest, &tmp_interest, sizeof(tmp_interest));
  if (raw_interest != 0) {
    total_size += 1 + 8;
  }

  // double deposit = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deposit = this->_internal_deposit();
  uint64_t raw_deposit;
  memcpy(&raw_deposit, &tmp_deposit, sizeof(tmp_deposit));
  if (raw_deposit != 0) {
    total_size += 1 + 8;
  }

  // double withdraw = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw = this->_internal_withdraw();
  uint64_t raw_withdraw;
  memcpy(&raw_withdraw, &tmp_withdraw, sizeof(tmp_withdraw));
  if (raw_withdraw != 0) {
    total_size += 1 + 8;
  }

  // double frozen_margin = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = this->_internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    total_size += 1 + 8;
  }

  // double frozen_cash = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = this->_internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    total_size += 1 + 8;
  }

  // double frozen_commission = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = this->_internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    total_size += 1 + 8;
  }

  // double curr_margin = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_margin = this->_internal_curr_margin();
  uint64_t raw_curr_margin;
  memcpy(&raw_curr_margin, &tmp_curr_margin, sizeof(tmp_curr_margin));
  if (raw_curr_margin != 0) {
    total_size += 1 + 8;
  }

  // double cash_in = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = this->_internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    total_size += 2 + 8;
  }

  // double commission = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = this->_internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    total_size += 2 + 8;
  }

  // double close_profit = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = this->_internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    total_size += 2 + 8;
  }

  // double position_profit = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = this->_internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    total_size += 2 + 8;
  }

  // double balance = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_balance = this->_internal_balance();
  uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    total_size += 2 + 8;
  }

  // double available = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_available = this->_internal_available();
  uint64_t raw_available;
  memcpy(&raw_available, &tmp_available, sizeof(tmp_available));
  if (raw_available != 0) {
    total_size += 2 + 8;
  }

  // double withdraw_quota = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw_quota = this->_internal_withdraw_quota();
  uint64_t raw_withdraw_quota;
  memcpy(&raw_withdraw_quota, &tmp_withdraw_quota, sizeof(tmp_withdraw_quota));
  if (raw_withdraw_quota != 0) {
    total_size += 2 + 8;
  }

  // double reserve = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve = this->_internal_reserve();
  uint64_t raw_reserve;
  memcpy(&raw_reserve, &tmp_reserve, sizeof(tmp_reserve));
  if (raw_reserve != 0) {
    total_size += 2 + 8;
  }

  // double credit = 26;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_credit = this->_internal_credit();
  uint64_t raw_credit;
  memcpy(&raw_credit, &tmp_credit, sizeof(tmp_credit));
  if (raw_credit != 0) {
    total_size += 2 + 8;
  }

  // double mortgage = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgage = this->_internal_mortgage();
  uint64_t raw_mortgage;
  memcpy(&raw_mortgage, &tmp_mortgage, sizeof(tmp_mortgage));
  if (raw_mortgage != 0) {
    total_size += 2 + 8;
  }

  // double exchange_margin = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = this->_internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    total_size += 2 + 8;
  }

  // double delivery_margin = 29;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delivery_margin = this->_internal_delivery_margin();
  uint64_t raw_delivery_margin;
  memcpy(&raw_delivery_margin, &tmp_delivery_margin, sizeof(tmp_delivery_margin));
  if (raw_delivery_margin != 0) {
    total_size += 2 + 8;
  }

  // double exchange_delivery_margin = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_delivery_margin = this->_internal_exchange_delivery_margin();
  uint64_t raw_exchange_delivery_margin;
  memcpy(&raw_exchange_delivery_margin, &tmp_exchange_delivery_margin, sizeof(tmp_exchange_delivery_margin));
  if (raw_exchange_delivery_margin != 0) {
    total_size += 2 + 8;
  }

  // double reserve_balance = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve_balance = this->_internal_reserve_balance();
  uint64_t raw_reserve_balance;
  memcpy(&raw_reserve_balance, &tmp_reserve_balance, sizeof(tmp_reserve_balance));
  if (raw_reserve_balance != 0) {
    total_size += 2 + 8;
  }

  // double pre_fund_mortgage_in = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_in = this->_internal_pre_fund_mortgage_in();
  uint64_t raw_pre_fund_mortgage_in;
  memcpy(&raw_pre_fund_mortgage_in, &tmp_pre_fund_mortgage_in, sizeof(tmp_pre_fund_mortgage_in));
  if (raw_pre_fund_mortgage_in != 0) {
    total_size += 2 + 8;
  }

  // double pre_fund_mortgage_out = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_out = this->_internal_pre_fund_mortgage_out();
  uint64_t raw_pre_fund_mortgage_out;
  memcpy(&raw_pre_fund_mortgage_out, &tmp_pre_fund_mortgage_out, sizeof(tmp_pre_fund_mortgage_out));
  if (raw_pre_fund_mortgage_out != 0) {
    total_size += 2 + 8;
  }

  // double fund_mortgage_in = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_in = this->_internal_fund_mortgage_in();
  uint64_t raw_fund_mortgage_in;
  memcpy(&raw_fund_mortgage_in, &tmp_fund_mortgage_in, sizeof(tmp_fund_mortgage_in));
  if (raw_fund_mortgage_in != 0) {
    total_size += 2 + 8;
  }

  // double fund_mortgage_out = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_out = this->_internal_fund_mortgage_out();
  uint64_t raw_fund_mortgage_out;
  memcpy(&raw_fund_mortgage_out, &tmp_fund_mortgage_out, sizeof(tmp_fund_mortgage_out));
  if (raw_fund_mortgage_out != 0) {
    total_size += 2 + 8;
  }

  // double fund_mortgage_available = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_available = this->_internal_fund_mortgage_available();
  uint64_t raw_fund_mortgage_available;
  memcpy(&raw_fund_mortgage_available, &tmp_fund_mortgage_available, sizeof(tmp_fund_mortgage_available));
  if (raw_fund_mortgage_available != 0) {
    total_size += 2 + 8;
  }

  // double mortgageable_fund = 38;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgageable_fund = this->_internal_mortgageable_fund();
  uint64_t raw_mortgageable_fund;
  memcpy(&raw_mortgageable_fund, &tmp_mortgageable_fund, sizeof(tmp_mortgageable_fund));
  if (raw_mortgageable_fund != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_margin = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_margin = this->_internal_spec_product_margin();
  uint64_t raw_spec_product_margin;
  memcpy(&raw_spec_product_margin, &tmp_spec_product_margin, sizeof(tmp_spec_product_margin));
  if (raw_spec_product_margin != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_frozen_margin = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_margin = this->_internal_spec_product_frozen_margin();
  uint64_t raw_spec_product_frozen_margin;
  memcpy(&raw_spec_product_frozen_margin, &tmp_spec_product_frozen_margin, sizeof(tmp_spec_product_frozen_margin));
  if (raw_spec_product_frozen_margin != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_commission = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_commission = this->_internal_spec_product_commission();
  uint64_t raw_spec_product_commission;
  memcpy(&raw_spec_product_commission, &tmp_spec_product_commission, sizeof(tmp_spec_product_commission));
  if (raw_spec_product_commission != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_frozen_commission = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_commission = this->_internal_spec_product_frozen_commission();
  uint64_t raw_spec_product_frozen_commission;
  memcpy(&raw_spec_product_frozen_commission, &tmp_spec_product_frozen_commission, sizeof(tmp_spec_product_frozen_commission));
  if (raw_spec_product_frozen_commission != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_position_profit = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit = this->_internal_spec_product_position_profit();
  uint64_t raw_spec_product_position_profit;
  memcpy(&raw_spec_product_position_profit, &tmp_spec_product_position_profit, sizeof(tmp_spec_product_position_profit));
  if (raw_spec_product_position_profit != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_close_profit = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_close_profit = this->_internal_spec_product_close_profit();
  uint64_t raw_spec_product_close_profit;
  memcpy(&raw_spec_product_close_profit, &tmp_spec_product_close_profit, sizeof(tmp_spec_product_close_profit));
  if (raw_spec_product_close_profit != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_position_profit_by_alg = 45;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit_by_alg = this->_internal_spec_product_position_profit_by_alg();
  uint64_t raw_spec_product_position_profit_by_alg;
  memcpy(&raw_spec_product_position_profit_by_alg, &tmp_spec_product_position_profit_by_alg, sizeof(tmp_spec_product_position_profit_by_alg));
  if (raw_spec_product_position_profit_by_alg != 0) {
    total_size += 2 + 8;
  }

  // double spec_product_exchange_margin = 46;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_exchange_margin = this->_internal_spec_product_exchange_margin();
  uint64_t raw_spec_product_exchange_margin;
  memcpy(&raw_spec_product_exchange_margin, &tmp_spec_product_exchange_margin, sizeof(tmp_spec_product_exchange_margin));
  if (raw_spec_product_exchange_margin != 0) {
    total_size += 2 + 8;
  }

  // double frozen_swap = 48;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_swap = this->_internal_frozen_swap();
  uint64_t raw_frozen_swap;
  memcpy(&raw_frozen_swap, &tmp_frozen_swap, sizeof(tmp_frozen_swap));
  if (raw_frozen_swap != 0) {
    total_size += 2 + 8;
  }

  // double remain_swap = 49;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_remain_swap = this->_internal_remain_swap();
  uint64_t raw_remain_swap;
  memcpy(&raw_remain_swap, &tmp_remain_swap, sizeof(tmp_remain_swap));
  if (raw_remain_swap != 0) {
    total_size += 2 + 8;
  }

  // int32 settlement_id = 25;
  if (this->_internal_settlement_id() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_settlement_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AccountInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountInfo::GetClassData() const { return &_class_data_; }

void AccountInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AccountInfo *>(to)->MergeFrom(
      static_cast<const AccountInfo &>(from));
}


void AccountInfo::MergeFrom(const AccountInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AccountInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_broker_id().empty()) {
    _internal_set_broker_id(from._internal_broker_id());
  }
  if (!from._internal_account_id().empty()) {
    _internal_set_account_id(from._internal_account_id());
  }
  if (!from._internal_trading_day().empty()) {
    _internal_set_trading_day(from._internal_trading_day());
  }
  if (!from._internal_currency_id().empty()) {
    _internal_set_currency_id(from._internal_currency_id());
  }
  if (!from._internal_biz_type().empty()) {
    _internal_set_biz_type(from._internal_biz_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_mortgage = from._internal_pre_mortgage();
  uint64_t raw_pre_mortgage;
  memcpy(&raw_pre_mortgage, &tmp_pre_mortgage, sizeof(tmp_pre_mortgage));
  if (raw_pre_mortgage != 0) {
    _internal_set_pre_mortgage(from._internal_pre_mortgage());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_credit = from._internal_pre_credit();
  uint64_t raw_pre_credit;
  memcpy(&raw_pre_credit, &tmp_pre_credit, sizeof(tmp_pre_credit));
  if (raw_pre_credit != 0) {
    _internal_set_pre_credit(from._internal_pre_credit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_deposit = from._internal_pre_deposit();
  uint64_t raw_pre_deposit;
  memcpy(&raw_pre_deposit, &tmp_pre_deposit, sizeof(tmp_pre_deposit));
  if (raw_pre_deposit != 0) {
    _internal_set_pre_deposit(from._internal_pre_deposit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_balance = from._internal_pre_balance();
  uint64_t raw_pre_balance;
  memcpy(&raw_pre_balance, &tmp_pre_balance, sizeof(tmp_pre_balance));
  if (raw_pre_balance != 0) {
    _internal_set_pre_balance(from._internal_pre_balance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = from._internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    _internal_set_pre_margin(from._internal_pre_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest_base = from._internal_interest_base();
  uint64_t raw_interest_base;
  memcpy(&raw_interest_base, &tmp_interest_base, sizeof(tmp_interest_base));
  if (raw_interest_base != 0) {
    _internal_set_interest_base(from._internal_interest_base());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_interest = from._internal_interest();
  uint64_t raw_interest;
  memcpy(&raw_interest, &tmp_interest, sizeof(tmp_interest));
  if (raw_interest != 0) {
    _internal_set_interest(from._internal_interest());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deposit = from._internal_deposit();
  uint64_t raw_deposit;
  memcpy(&raw_deposit, &tmp_deposit, sizeof(tmp_deposit));
  if (raw_deposit != 0) {
    _internal_set_deposit(from._internal_deposit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw = from._internal_withdraw();
  uint64_t raw_withdraw;
  memcpy(&raw_withdraw, &tmp_withdraw, sizeof(tmp_withdraw));
  if (raw_withdraw != 0) {
    _internal_set_withdraw(from._internal_withdraw());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = from._internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    _internal_set_frozen_margin(from._internal_frozen_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = from._internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    _internal_set_frozen_cash(from._internal_frozen_cash());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = from._internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    _internal_set_frozen_commission(from._internal_frozen_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_margin = from._internal_curr_margin();
  uint64_t raw_curr_margin;
  memcpy(&raw_curr_margin, &tmp_curr_margin, sizeof(tmp_curr_margin));
  if (raw_curr_margin != 0) {
    _internal_set_curr_margin(from._internal_curr_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = from._internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    _internal_set_cash_in(from._internal_cash_in());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = from._internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    _internal_set_commission(from._internal_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = from._internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    _internal_set_close_profit(from._internal_close_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = from._internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    _internal_set_position_profit(from._internal_position_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_balance = from._internal_balance();
  uint64_t raw_balance;
  memcpy(&raw_balance, &tmp_balance, sizeof(tmp_balance));
  if (raw_balance != 0) {
    _internal_set_balance(from._internal_balance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_available = from._internal_available();
  uint64_t raw_available;
  memcpy(&raw_available, &tmp_available, sizeof(tmp_available));
  if (raw_available != 0) {
    _internal_set_available(from._internal_available());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_withdraw_quota = from._internal_withdraw_quota();
  uint64_t raw_withdraw_quota;
  memcpy(&raw_withdraw_quota, &tmp_withdraw_quota, sizeof(tmp_withdraw_quota));
  if (raw_withdraw_quota != 0) {
    _internal_set_withdraw_quota(from._internal_withdraw_quota());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve = from._internal_reserve();
  uint64_t raw_reserve;
  memcpy(&raw_reserve, &tmp_reserve, sizeof(tmp_reserve));
  if (raw_reserve != 0) {
    _internal_set_reserve(from._internal_reserve());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_credit = from._internal_credit();
  uint64_t raw_credit;
  memcpy(&raw_credit, &tmp_credit, sizeof(tmp_credit));
  if (raw_credit != 0) {
    _internal_set_credit(from._internal_credit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgage = from._internal_mortgage();
  uint64_t raw_mortgage;
  memcpy(&raw_mortgage, &tmp_mortgage, sizeof(tmp_mortgage));
  if (raw_mortgage != 0) {
    _internal_set_mortgage(from._internal_mortgage());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = from._internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    _internal_set_exchange_margin(from._internal_exchange_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delivery_margin = from._internal_delivery_margin();
  uint64_t raw_delivery_margin;
  memcpy(&raw_delivery_margin, &tmp_delivery_margin, sizeof(tmp_delivery_margin));
  if (raw_delivery_margin != 0) {
    _internal_set_delivery_margin(from._internal_delivery_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_delivery_margin = from._internal_exchange_delivery_margin();
  uint64_t raw_exchange_delivery_margin;
  memcpy(&raw_exchange_delivery_margin, &tmp_exchange_delivery_margin, sizeof(tmp_exchange_delivery_margin));
  if (raw_exchange_delivery_margin != 0) {
    _internal_set_exchange_delivery_margin(from._internal_exchange_delivery_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reserve_balance = from._internal_reserve_balance();
  uint64_t raw_reserve_balance;
  memcpy(&raw_reserve_balance, &tmp_reserve_balance, sizeof(tmp_reserve_balance));
  if (raw_reserve_balance != 0) {
    _internal_set_reserve_balance(from._internal_reserve_balance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_in = from._internal_pre_fund_mortgage_in();
  uint64_t raw_pre_fund_mortgage_in;
  memcpy(&raw_pre_fund_mortgage_in, &tmp_pre_fund_mortgage_in, sizeof(tmp_pre_fund_mortgage_in));
  if (raw_pre_fund_mortgage_in != 0) {
    _internal_set_pre_fund_mortgage_in(from._internal_pre_fund_mortgage_in());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_fund_mortgage_out = from._internal_pre_fund_mortgage_out();
  uint64_t raw_pre_fund_mortgage_out;
  memcpy(&raw_pre_fund_mortgage_out, &tmp_pre_fund_mortgage_out, sizeof(tmp_pre_fund_mortgage_out));
  if (raw_pre_fund_mortgage_out != 0) {
    _internal_set_pre_fund_mortgage_out(from._internal_pre_fund_mortgage_out());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_in = from._internal_fund_mortgage_in();
  uint64_t raw_fund_mortgage_in;
  memcpy(&raw_fund_mortgage_in, &tmp_fund_mortgage_in, sizeof(tmp_fund_mortgage_in));
  if (raw_fund_mortgage_in != 0) {
    _internal_set_fund_mortgage_in(from._internal_fund_mortgage_in());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_out = from._internal_fund_mortgage_out();
  uint64_t raw_fund_mortgage_out;
  memcpy(&raw_fund_mortgage_out, &tmp_fund_mortgage_out, sizeof(tmp_fund_mortgage_out));
  if (raw_fund_mortgage_out != 0) {
    _internal_set_fund_mortgage_out(from._internal_fund_mortgage_out());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fund_mortgage_available = from._internal_fund_mortgage_available();
  uint64_t raw_fund_mortgage_available;
  memcpy(&raw_fund_mortgage_available, &tmp_fund_mortgage_available, sizeof(tmp_fund_mortgage_available));
  if (raw_fund_mortgage_available != 0) {
    _internal_set_fund_mortgage_available(from._internal_fund_mortgage_available());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mortgageable_fund = from._internal_mortgageable_fund();
  uint64_t raw_mortgageable_fund;
  memcpy(&raw_mortgageable_fund, &tmp_mortgageable_fund, sizeof(tmp_mortgageable_fund));
  if (raw_mortgageable_fund != 0) {
    _internal_set_mortgageable_fund(from._internal_mortgageable_fund());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_margin = from._internal_spec_product_margin();
  uint64_t raw_spec_product_margin;
  memcpy(&raw_spec_product_margin, &tmp_spec_product_margin, sizeof(tmp_spec_product_margin));
  if (raw_spec_product_margin != 0) {
    _internal_set_spec_product_margin(from._internal_spec_product_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_margin = from._internal_spec_product_frozen_margin();
  uint64_t raw_spec_product_frozen_margin;
  memcpy(&raw_spec_product_frozen_margin, &tmp_spec_product_frozen_margin, sizeof(tmp_spec_product_frozen_margin));
  if (raw_spec_product_frozen_margin != 0) {
    _internal_set_spec_product_frozen_margin(from._internal_spec_product_frozen_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_commission = from._internal_spec_product_commission();
  uint64_t raw_spec_product_commission;
  memcpy(&raw_spec_product_commission, &tmp_spec_product_commission, sizeof(tmp_spec_product_commission));
  if (raw_spec_product_commission != 0) {
    _internal_set_spec_product_commission(from._internal_spec_product_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_frozen_commission = from._internal_spec_product_frozen_commission();
  uint64_t raw_spec_product_frozen_commission;
  memcpy(&raw_spec_product_frozen_commission, &tmp_spec_product_frozen_commission, sizeof(tmp_spec_product_frozen_commission));
  if (raw_spec_product_frozen_commission != 0) {
    _internal_set_spec_product_frozen_commission(from._internal_spec_product_frozen_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit = from._internal_spec_product_position_profit();
  uint64_t raw_spec_product_position_profit;
  memcpy(&raw_spec_product_position_profit, &tmp_spec_product_position_profit, sizeof(tmp_spec_product_position_profit));
  if (raw_spec_product_position_profit != 0) {
    _internal_set_spec_product_position_profit(from._internal_spec_product_position_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_close_profit = from._internal_spec_product_close_profit();
  uint64_t raw_spec_product_close_profit;
  memcpy(&raw_spec_product_close_profit, &tmp_spec_product_close_profit, sizeof(tmp_spec_product_close_profit));
  if (raw_spec_product_close_profit != 0) {
    _internal_set_spec_product_close_profit(from._internal_spec_product_close_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_position_profit_by_alg = from._internal_spec_product_position_profit_by_alg();
  uint64_t raw_spec_product_position_profit_by_alg;
  memcpy(&raw_spec_product_position_profit_by_alg, &tmp_spec_product_position_profit_by_alg, sizeof(tmp_spec_product_position_profit_by_alg));
  if (raw_spec_product_position_profit_by_alg != 0) {
    _internal_set_spec_product_position_profit_by_alg(from._internal_spec_product_position_profit_by_alg());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spec_product_exchange_margin = from._internal_spec_product_exchange_margin();
  uint64_t raw_spec_product_exchange_margin;
  memcpy(&raw_spec_product_exchange_margin, &tmp_spec_product_exchange_margin, sizeof(tmp_spec_product_exchange_margin));
  if (raw_spec_product_exchange_margin != 0) {
    _internal_set_spec_product_exchange_margin(from._internal_spec_product_exchange_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_swap = from._internal_frozen_swap();
  uint64_t raw_frozen_swap;
  memcpy(&raw_frozen_swap, &tmp_frozen_swap, sizeof(tmp_frozen_swap));
  if (raw_frozen_swap != 0) {
    _internal_set_frozen_swap(from._internal_frozen_swap());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_remain_swap = from._internal_remain_swap();
  uint64_t raw_remain_swap;
  memcpy(&raw_remain_swap, &tmp_remain_swap, sizeof(tmp_remain_swap));
  if (raw_remain_swap != 0) {
    _internal_set_remain_swap(from._internal_remain_swap());
  }
  if (from._internal_settlement_id() != 0) {
    _internal_set_settlement_id(from._internal_settlement_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountInfo::CopyFrom(const AccountInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AccountInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountInfo::IsInitialized() const {
  return true;
}

void AccountInfo::InternalSwap(AccountInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &broker_id_, lhs_arena,
      &other->broker_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &account_id_, lhs_arena,
      &other->account_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &trading_day_, lhs_arena,
      &other->trading_day_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &currency_id_, lhs_arena,
      &other->currency_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &biz_type_, lhs_arena,
      &other->biz_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccountInfo, settlement_id_)
      + sizeof(AccountInfo::settlement_id_)
      - PROTOBUF_FIELD_OFFSET(AccountInfo, pre_mortgage_)>(
          reinterpret_cast<char*>(&pre_mortgage_),
          reinterpret_cast<char*>(&other->pre_mortgage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_account_2eproto_getter, &descriptor_table_account_2eproto_once,
      file_level_metadata_account_2eproto[0]);
}

// ===================================================================

class Position::_Internal {
 public:
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  reserve1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reserve1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_reserve1().empty()) {
    reserve1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_reserve1(), 
      GetArenaForAllocation());
  }
  broker_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    broker_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_broker_id().empty()) {
    broker_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_broker_id(), 
      GetArenaForAllocation());
  }
  investor_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    investor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_investor_id().empty()) {
    investor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_investor_id(), 
      GetArenaForAllocation());
  }
  posi_direction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    posi_direction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_posi_direction().empty()) {
    posi_direction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_posi_direction(), 
      GetArenaForAllocation());
  }
  hedge_flag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hedge_flag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hedge_flag().empty()) {
    hedge_flag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hedge_flag(), 
      GetArenaForAllocation());
  }
  position_date_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    position_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_position_date().empty()) {
    position_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_position_date(), 
      GetArenaForAllocation());
  }
  exchange_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    exchange_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_exchange_id().empty()) {
    exchange_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_exchange_id(), 
      GetArenaForAllocation());
  }
  instrument_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    instrument_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_instrument_id().empty()) {
    instrument_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_instrument_id(), 
      GetArenaForAllocation());
  }
  instrument_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    instrument_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_instrument_name().empty()) {
    instrument_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_instrument_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&position_, &from.position_,
    static_cast<size_t>(reinterpret_cast<char*>(&position_cost_offset_) -
    reinterpret_cast<char*>(&position_)) + sizeof(position_cost_offset_));
  // @@protoc_insertion_point(copy_constructor:Position)
}

inline void Position::SharedCtor() {
reserve1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reserve1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
broker_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  broker_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
investor_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  investor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
posi_direction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  posi_direction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hedge_flag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hedge_flag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
position_date_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  position_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
exchange_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  exchange_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
instrument_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  instrument_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
instrument_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  instrument_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&position_cost_offset_) -
    reinterpret_cast<char*>(&position_)) + sizeof(position_cost_offset_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:Position)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reserve1_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  broker_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  investor_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  posi_direction_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hedge_flag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  position_date_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  exchange_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  instrument_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  instrument_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Position::ArenaDtor(void* object) {
  Position* _this = reinterpret_cast< Position* >(object);
  (void)_this;
}
void Position::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Position::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reserve1_.ClearToEmpty();
  broker_id_.ClearToEmpty();
  investor_id_.ClearToEmpty();
  posi_direction_.ClearToEmpty();
  hedge_flag_.ClearToEmpty();
  position_date_.ClearToEmpty();
  exchange_id_.ClearToEmpty();
  instrument_id_.ClearToEmpty();
  instrument_name_.ClearToEmpty();
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&position_cost_offset_) -
      reinterpret_cast<char*>(&position_)) + sizeof(position_cost_offset_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string reserve1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reserve1();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.reserve1"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string broker_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_broker_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.broker_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string investor_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_investor_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.investor_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string posi_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_posi_direction();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.posi_direction"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hedge_flag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_hedge_flag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.hedge_flag"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string position_date = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_position_date();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.position_date"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 yd_position = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          yd_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 today_position = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          today_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 open_volume = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          open_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 close_volume = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          close_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double open_amount = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          open_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double close_amount = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          close_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double position_cost = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          position_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double close_profit = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          close_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double position_profit = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          position_profit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double open_cost = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          open_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 long_frozen = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          long_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 short_frozen = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          short_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double long_frozen_amount = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          long_frozen_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double short_frozen_amount = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          short_frozen_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_margin = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          pre_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double use_margin = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          use_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_margin = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          frozen_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_cash = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          frozen_cash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double frozen_commission = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          frozen_commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cash_in = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          cash_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double commission = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 225)) {
          commission_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pre_settlement_price = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          pre_settlement_price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double settlement_price = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          settlement_price_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 settlement_id = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          settlement_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double exchange_margin = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          exchange_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 comb_position = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          comb_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 comb_long_frozen = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          comb_long_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 comb_short_frozen = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          comb_short_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double close_profit_by_date = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          close_profit_by_date_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double close_profit_by_trade = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          close_profit_by_trade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 strike_frozen = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          strike_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double strike_frozen_amount = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          strike_frozen_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 abandon_frozen = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          abandon_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string exchange_id = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_exchange_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.exchange_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 yd_strike_frozen = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          yd_strike_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double position_cost_offset = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          position_cost_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string instrument_id = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_instrument_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.instrument_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string instrument_name = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_instrument_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Position.instrument_name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string reserve1 = 1;
  if (!this->_internal_reserve1().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reserve1().data(), static_cast<int>(this->_internal_reserve1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.reserve1");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_reserve1(), target);
  }

  // string broker_id = 2;
  if (!this->_internal_broker_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_broker_id().data(), static_cast<int>(this->_internal_broker_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.broker_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_broker_id(), target);
  }

  // string investor_id = 3;
  if (!this->_internal_investor_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_investor_id().data(), static_cast<int>(this->_internal_investor_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.investor_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_investor_id(), target);
  }

  // string posi_direction = 4;
  if (!this->_internal_posi_direction().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_posi_direction().data(), static_cast<int>(this->_internal_posi_direction().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.posi_direction");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_posi_direction(), target);
  }

  // string hedge_flag = 5;
  if (!this->_internal_hedge_flag().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hedge_flag().data(), static_cast<int>(this->_internal_hedge_flag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.hedge_flag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_hedge_flag(), target);
  }

  // string position_date = 6;
  if (!this->_internal_position_date().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_position_date().data(), static_cast<int>(this->_internal_position_date().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.position_date");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_position_date(), target);
  }

  // int32 position = 7;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_position(), target);
  }

  // int32 yd_position = 8;
  if (this->_internal_yd_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_yd_position(), target);
  }

  // int32 today_position = 9;
  if (this->_internal_today_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_today_position(), target);
  }

  // int32 open_volume = 10;
  if (this->_internal_open_volume() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_open_volume(), target);
  }

  // int32 close_volume = 11;
  if (this->_internal_close_volume() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_close_volume(), target);
  }

  // double open_amount = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_amount = this->_internal_open_amount();
  uint64_t raw_open_amount;
  memcpy(&raw_open_amount, &tmp_open_amount, sizeof(tmp_open_amount));
  if (raw_open_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_open_amount(), target);
  }

  // double close_amount = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_amount = this->_internal_close_amount();
  uint64_t raw_close_amount;
  memcpy(&raw_close_amount, &tmp_close_amount, sizeof(tmp_close_amount));
  if (raw_close_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_close_amount(), target);
  }

  // double position_cost = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost = this->_internal_position_cost();
  uint64_t raw_position_cost;
  memcpy(&raw_position_cost, &tmp_position_cost, sizeof(tmp_position_cost));
  if (raw_position_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_position_cost(), target);
  }

  // double close_profit = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = this->_internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(15, this->_internal_close_profit(), target);
  }

  // double position_profit = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = this->_internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(16, this->_internal_position_profit(), target);
  }

  // double open_cost = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_cost = this->_internal_open_cost();
  uint64_t raw_open_cost;
  memcpy(&raw_open_cost, &tmp_open_cost, sizeof(tmp_open_cost));
  if (raw_open_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(17, this->_internal_open_cost(), target);
  }

  // int32 long_frozen = 18;
  if (this->_internal_long_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(18, this->_internal_long_frozen(), target);
  }

  // int32 short_frozen = 19;
  if (this->_internal_short_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_short_frozen(), target);
  }

  // double long_frozen_amount = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_long_frozen_amount = this->_internal_long_frozen_amount();
  uint64_t raw_long_frozen_amount;
  memcpy(&raw_long_frozen_amount, &tmp_long_frozen_amount, sizeof(tmp_long_frozen_amount));
  if (raw_long_frozen_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(20, this->_internal_long_frozen_amount(), target);
  }

  // double short_frozen_amount = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_short_frozen_amount = this->_internal_short_frozen_amount();
  uint64_t raw_short_frozen_amount;
  memcpy(&raw_short_frozen_amount, &tmp_short_frozen_amount, sizeof(tmp_short_frozen_amount));
  if (raw_short_frozen_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_short_frozen_amount(), target);
  }

  // double pre_margin = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = this->_internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(22, this->_internal_pre_margin(), target);
  }

  // double use_margin = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_use_margin = this->_internal_use_margin();
  uint64_t raw_use_margin;
  memcpy(&raw_use_margin, &tmp_use_margin, sizeof(tmp_use_margin));
  if (raw_use_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(23, this->_internal_use_margin(), target);
  }

  // double frozen_margin = 24;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = this->_internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(24, this->_internal_frozen_margin(), target);
  }

  // double frozen_cash = 25;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = this->_internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(25, this->_internal_frozen_cash(), target);
  }

  // double frozen_commission = 26;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = this->_internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(26, this->_internal_frozen_commission(), target);
  }

  // double cash_in = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = this->_internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(27, this->_internal_cash_in(), target);
  }

  // double commission = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = this->_internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(28, this->_internal_commission(), target);
  }

  // double pre_settlement_price = 29;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_settlement_price = this->_internal_pre_settlement_price();
  uint64_t raw_pre_settlement_price;
  memcpy(&raw_pre_settlement_price, &tmp_pre_settlement_price, sizeof(tmp_pre_settlement_price));
  if (raw_pre_settlement_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(29, this->_internal_pre_settlement_price(), target);
  }

  // double settlement_price = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_settlement_price = this->_internal_settlement_price();
  uint64_t raw_settlement_price;
  memcpy(&raw_settlement_price, &tmp_settlement_price, sizeof(tmp_settlement_price));
  if (raw_settlement_price != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(30, this->_internal_settlement_price(), target);
  }

  // int32 settlement_id = 31;
  if (this->_internal_settlement_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(31, this->_internal_settlement_id(), target);
  }

  // double exchange_margin = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = this->_internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(32, this->_internal_exchange_margin(), target);
  }

  // int32 comb_position = 33;
  if (this->_internal_comb_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(33, this->_internal_comb_position(), target);
  }

  // int32 comb_long_frozen = 34;
  if (this->_internal_comb_long_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(34, this->_internal_comb_long_frozen(), target);
  }

  // int32 comb_short_frozen = 35;
  if (this->_internal_comb_short_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(35, this->_internal_comb_short_frozen(), target);
  }

  // double close_profit_by_date = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_date = this->_internal_close_profit_by_date();
  uint64_t raw_close_profit_by_date;
  memcpy(&raw_close_profit_by_date, &tmp_close_profit_by_date, sizeof(tmp_close_profit_by_date));
  if (raw_close_profit_by_date != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(36, this->_internal_close_profit_by_date(), target);
  }

  // double close_profit_by_trade = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_trade = this->_internal_close_profit_by_trade();
  uint64_t raw_close_profit_by_trade;
  memcpy(&raw_close_profit_by_trade, &tmp_close_profit_by_trade, sizeof(tmp_close_profit_by_trade));
  if (raw_close_profit_by_trade != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(37, this->_internal_close_profit_by_trade(), target);
  }

  // int32 strike_frozen = 38;
  if (this->_internal_strike_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(38, this->_internal_strike_frozen(), target);
  }

  // double strike_frozen_amount = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_strike_frozen_amount = this->_internal_strike_frozen_amount();
  uint64_t raw_strike_frozen_amount;
  memcpy(&raw_strike_frozen_amount, &tmp_strike_frozen_amount, sizeof(tmp_strike_frozen_amount));
  if (raw_strike_frozen_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(39, this->_internal_strike_frozen_amount(), target);
  }

  // int32 abandon_frozen = 40;
  if (this->_internal_abandon_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_abandon_frozen(), target);
  }

  // string exchange_id = 41;
  if (!this->_internal_exchange_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_exchange_id().data(), static_cast<int>(this->_internal_exchange_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.exchange_id");
    target = stream->WriteStringMaybeAliased(
        41, this->_internal_exchange_id(), target);
  }

  // int32 yd_strike_frozen = 42;
  if (this->_internal_yd_strike_frozen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(42, this->_internal_yd_strike_frozen(), target);
  }

  // double position_cost_offset = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost_offset = this->_internal_position_cost_offset();
  uint64_t raw_position_cost_offset;
  memcpy(&raw_position_cost_offset, &tmp_position_cost_offset, sizeof(tmp_position_cost_offset));
  if (raw_position_cost_offset != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(43, this->_internal_position_cost_offset(), target);
  }

  // string instrument_id = 44;
  if (!this->_internal_instrument_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instrument_id().data(), static_cast<int>(this->_internal_instrument_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.instrument_id");
    target = stream->WriteStringMaybeAliased(
        44, this->_internal_instrument_id(), target);
  }

  // string instrument_name = 45;
  if (!this->_internal_instrument_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instrument_name().data(), static_cast<int>(this->_internal_instrument_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Position.instrument_name");
    target = stream->WriteStringMaybeAliased(
        45, this->_internal_instrument_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Position)
  return target;
}

size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string reserve1 = 1;
  if (!this->_internal_reserve1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_reserve1());
  }

  // string broker_id = 2;
  if (!this->_internal_broker_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_broker_id());
  }

  // string investor_id = 3;
  if (!this->_internal_investor_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_investor_id());
  }

  // string posi_direction = 4;
  if (!this->_internal_posi_direction().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_posi_direction());
  }

  // string hedge_flag = 5;
  if (!this->_internal_hedge_flag().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hedge_flag());
  }

  // string position_date = 6;
  if (!this->_internal_position_date().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_position_date());
  }

  // string exchange_id = 41;
  if (!this->_internal_exchange_id().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_exchange_id());
  }

  // string instrument_id = 44;
  if (!this->_internal_instrument_id().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_instrument_id());
  }

  // string instrument_name = 45;
  if (!this->_internal_instrument_name().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_instrument_name());
  }

  // int32 position = 7;
  if (this->_internal_position() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_position());
  }

  // int32 yd_position = 8;
  if (this->_internal_yd_position() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_yd_position());
  }

  // int32 today_position = 9;
  if (this->_internal_today_position() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_today_position());
  }

  // int32 open_volume = 10;
  if (this->_internal_open_volume() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_open_volume());
  }

  // double open_amount = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_amount = this->_internal_open_amount();
  uint64_t raw_open_amount;
  memcpy(&raw_open_amount, &tmp_open_amount, sizeof(tmp_open_amount));
  if (raw_open_amount != 0) {
    total_size += 1 + 8;
  }

  // double close_amount = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_amount = this->_internal_close_amount();
  uint64_t raw_close_amount;
  memcpy(&raw_close_amount, &tmp_close_amount, sizeof(tmp_close_amount));
  if (raw_close_amount != 0) {
    total_size += 1 + 8;
  }

  // double position_cost = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost = this->_internal_position_cost();
  uint64_t raw_position_cost;
  memcpy(&raw_position_cost, &tmp_position_cost, sizeof(tmp_position_cost));
  if (raw_position_cost != 0) {
    total_size += 1 + 8;
  }

  // int32 close_volume = 11;
  if (this->_internal_close_volume() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_close_volume());
  }

  // int32 long_frozen = 18;
  if (this->_internal_long_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_long_frozen());
  }

  // double close_profit = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = this->_internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    total_size += 1 + 8;
  }

  // double position_profit = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = this->_internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    total_size += 2 + 8;
  }

  // double open_cost = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_cost = this->_internal_open_cost();
  uint64_t raw_open_cost;
  memcpy(&raw_open_cost, &tmp_open_cost, sizeof(tmp_open_cost));
  if (raw_open_cost != 0) {
    total_size += 2 + 8;
  }

  // double long_frozen_amount = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_long_frozen_amount = this->_internal_long_frozen_amount();
  uint64_t raw_long_frozen_amount;
  memcpy(&raw_long_frozen_amount, &tmp_long_frozen_amount, sizeof(tmp_long_frozen_amount));
  if (raw_long_frozen_amount != 0) {
    total_size += 2 + 8;
  }

  // double short_frozen_amount = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_short_frozen_amount = this->_internal_short_frozen_amount();
  uint64_t raw_short_frozen_amount;
  memcpy(&raw_short_frozen_amount, &tmp_short_frozen_amount, sizeof(tmp_short_frozen_amount));
  if (raw_short_frozen_amount != 0) {
    total_size += 2 + 8;
  }

  // double pre_margin = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = this->_internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    total_size += 2 + 8;
  }

  // double use_margin = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_use_margin = this->_internal_use_margin();
  uint64_t raw_use_margin;
  memcpy(&raw_use_margin, &tmp_use_margin, sizeof(tmp_use_margin));
  if (raw_use_margin != 0) {
    total_size += 2 + 8;
  }

  // double frozen_margin = 24;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = this->_internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    total_size += 2 + 8;
  }

  // double frozen_cash = 25;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = this->_internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    total_size += 2 + 8;
  }

  // int32 short_frozen = 19;
  if (this->_internal_short_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_short_frozen());
  }

  // int32 settlement_id = 31;
  if (this->_internal_settlement_id() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_settlement_id());
  }

  // double frozen_commission = 26;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = this->_internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    total_size += 2 + 8;
  }

  // double cash_in = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = this->_internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    total_size += 2 + 8;
  }

  // double commission = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = this->_internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    total_size += 2 + 8;
  }

  // double pre_settlement_price = 29;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_settlement_price = this->_internal_pre_settlement_price();
  uint64_t raw_pre_settlement_price;
  memcpy(&raw_pre_settlement_price, &tmp_pre_settlement_price, sizeof(tmp_pre_settlement_price));
  if (raw_pre_settlement_price != 0) {
    total_size += 2 + 8;
  }

  // double settlement_price = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_settlement_price = this->_internal_settlement_price();
  uint64_t raw_settlement_price;
  memcpy(&raw_settlement_price, &tmp_settlement_price, sizeof(tmp_settlement_price));
  if (raw_settlement_price != 0) {
    total_size += 2 + 8;
  }

  // double exchange_margin = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = this->_internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    total_size += 2 + 8;
  }

  // int32 comb_position = 33;
  if (this->_internal_comb_position() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_comb_position());
  }

  // int32 comb_long_frozen = 34;
  if (this->_internal_comb_long_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_comb_long_frozen());
  }

  // double close_profit_by_date = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_date = this->_internal_close_profit_by_date();
  uint64_t raw_close_profit_by_date;
  memcpy(&raw_close_profit_by_date, &tmp_close_profit_by_date, sizeof(tmp_close_profit_by_date));
  if (raw_close_profit_by_date != 0) {
    total_size += 2 + 8;
  }

  // int32 comb_short_frozen = 35;
  if (this->_internal_comb_short_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_comb_short_frozen());
  }

  // int32 strike_frozen = 38;
  if (this->_internal_strike_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_strike_frozen());
  }

  // double close_profit_by_trade = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_trade = this->_internal_close_profit_by_trade();
  uint64_t raw_close_profit_by_trade;
  memcpy(&raw_close_profit_by_trade, &tmp_close_profit_by_trade, sizeof(tmp_close_profit_by_trade));
  if (raw_close_profit_by_trade != 0) {
    total_size += 2 + 8;
  }

  // double strike_frozen_amount = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_strike_frozen_amount = this->_internal_strike_frozen_amount();
  uint64_t raw_strike_frozen_amount;
  memcpy(&raw_strike_frozen_amount, &tmp_strike_frozen_amount, sizeof(tmp_strike_frozen_amount));
  if (raw_strike_frozen_amount != 0) {
    total_size += 2 + 8;
  }

  // int32 abandon_frozen = 40;
  if (this->_internal_abandon_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_abandon_frozen());
  }

  // int32 yd_strike_frozen = 42;
  if (this->_internal_yd_strike_frozen() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_yd_strike_frozen());
  }

  // double position_cost_offset = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost_offset = this->_internal_position_cost_offset();
  uint64_t raw_position_cost_offset;
  memcpy(&raw_position_cost_offset, &tmp_position_cost_offset, sizeof(tmp_position_cost_offset));
  if (raw_position_cost_offset != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }

void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Position *>(to)->MergeFrom(
      static_cast<const Position &>(from));
}


void Position::MergeFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Position)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_reserve1().empty()) {
    _internal_set_reserve1(from._internal_reserve1());
  }
  if (!from._internal_broker_id().empty()) {
    _internal_set_broker_id(from._internal_broker_id());
  }
  if (!from._internal_investor_id().empty()) {
    _internal_set_investor_id(from._internal_investor_id());
  }
  if (!from._internal_posi_direction().empty()) {
    _internal_set_posi_direction(from._internal_posi_direction());
  }
  if (!from._internal_hedge_flag().empty()) {
    _internal_set_hedge_flag(from._internal_hedge_flag());
  }
  if (!from._internal_position_date().empty()) {
    _internal_set_position_date(from._internal_position_date());
  }
  if (!from._internal_exchange_id().empty()) {
    _internal_set_exchange_id(from._internal_exchange_id());
  }
  if (!from._internal_instrument_id().empty()) {
    _internal_set_instrument_id(from._internal_instrument_id());
  }
  if (!from._internal_instrument_name().empty()) {
    _internal_set_instrument_name(from._internal_instrument_name());
  }
  if (from._internal_position() != 0) {
    _internal_set_position(from._internal_position());
  }
  if (from._internal_yd_position() != 0) {
    _internal_set_yd_position(from._internal_yd_position());
  }
  if (from._internal_today_position() != 0) {
    _internal_set_today_position(from._internal_today_position());
  }
  if (from._internal_open_volume() != 0) {
    _internal_set_open_volume(from._internal_open_volume());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_amount = from._internal_open_amount();
  uint64_t raw_open_amount;
  memcpy(&raw_open_amount, &tmp_open_amount, sizeof(tmp_open_amount));
  if (raw_open_amount != 0) {
    _internal_set_open_amount(from._internal_open_amount());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_amount = from._internal_close_amount();
  uint64_t raw_close_amount;
  memcpy(&raw_close_amount, &tmp_close_amount, sizeof(tmp_close_amount));
  if (raw_close_amount != 0) {
    _internal_set_close_amount(from._internal_close_amount());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost = from._internal_position_cost();
  uint64_t raw_position_cost;
  memcpy(&raw_position_cost, &tmp_position_cost, sizeof(tmp_position_cost));
  if (raw_position_cost != 0) {
    _internal_set_position_cost(from._internal_position_cost());
  }
  if (from._internal_close_volume() != 0) {
    _internal_set_close_volume(from._internal_close_volume());
  }
  if (from._internal_long_frozen() != 0) {
    _internal_set_long_frozen(from._internal_long_frozen());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit = from._internal_close_profit();
  uint64_t raw_close_profit;
  memcpy(&raw_close_profit, &tmp_close_profit, sizeof(tmp_close_profit));
  if (raw_close_profit != 0) {
    _internal_set_close_profit(from._internal_close_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_profit = from._internal_position_profit();
  uint64_t raw_position_profit;
  memcpy(&raw_position_profit, &tmp_position_profit, sizeof(tmp_position_profit));
  if (raw_position_profit != 0) {
    _internal_set_position_profit(from._internal_position_profit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_open_cost = from._internal_open_cost();
  uint64_t raw_open_cost;
  memcpy(&raw_open_cost, &tmp_open_cost, sizeof(tmp_open_cost));
  if (raw_open_cost != 0) {
    _internal_set_open_cost(from._internal_open_cost());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_long_frozen_amount = from._internal_long_frozen_amount();
  uint64_t raw_long_frozen_amount;
  memcpy(&raw_long_frozen_amount, &tmp_long_frozen_amount, sizeof(tmp_long_frozen_amount));
  if (raw_long_frozen_amount != 0) {
    _internal_set_long_frozen_amount(from._internal_long_frozen_amount());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_short_frozen_amount = from._internal_short_frozen_amount();
  uint64_t raw_short_frozen_amount;
  memcpy(&raw_short_frozen_amount, &tmp_short_frozen_amount, sizeof(tmp_short_frozen_amount));
  if (raw_short_frozen_amount != 0) {
    _internal_set_short_frozen_amount(from._internal_short_frozen_amount());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_margin = from._internal_pre_margin();
  uint64_t raw_pre_margin;
  memcpy(&raw_pre_margin, &tmp_pre_margin, sizeof(tmp_pre_margin));
  if (raw_pre_margin != 0) {
    _internal_set_pre_margin(from._internal_pre_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_use_margin = from._internal_use_margin();
  uint64_t raw_use_margin;
  memcpy(&raw_use_margin, &tmp_use_margin, sizeof(tmp_use_margin));
  if (raw_use_margin != 0) {
    _internal_set_use_margin(from._internal_use_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_margin = from._internal_frozen_margin();
  uint64_t raw_frozen_margin;
  memcpy(&raw_frozen_margin, &tmp_frozen_margin, sizeof(tmp_frozen_margin));
  if (raw_frozen_margin != 0) {
    _internal_set_frozen_margin(from._internal_frozen_margin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_cash = from._internal_frozen_cash();
  uint64_t raw_frozen_cash;
  memcpy(&raw_frozen_cash, &tmp_frozen_cash, sizeof(tmp_frozen_cash));
  if (raw_frozen_cash != 0) {
    _internal_set_frozen_cash(from._internal_frozen_cash());
  }
  if (from._internal_short_frozen() != 0) {
    _internal_set_short_frozen(from._internal_short_frozen());
  }
  if (from._internal_settlement_id() != 0) {
    _internal_set_settlement_id(from._internal_settlement_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frozen_commission = from._internal_frozen_commission();
  uint64_t raw_frozen_commission;
  memcpy(&raw_frozen_commission, &tmp_frozen_commission, sizeof(tmp_frozen_commission));
  if (raw_frozen_commission != 0) {
    _internal_set_frozen_commission(from._internal_frozen_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cash_in = from._internal_cash_in();
  uint64_t raw_cash_in;
  memcpy(&raw_cash_in, &tmp_cash_in, sizeof(tmp_cash_in));
  if (raw_cash_in != 0) {
    _internal_set_cash_in(from._internal_cash_in());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_commission = from._internal_commission();
  uint64_t raw_commission;
  memcpy(&raw_commission, &tmp_commission, sizeof(tmp_commission));
  if (raw_commission != 0) {
    _internal_set_commission(from._internal_commission());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pre_settlement_price = from._internal_pre_settlement_price();
  uint64_t raw_pre_settlement_price;
  memcpy(&raw_pre_settlement_price, &tmp_pre_settlement_price, sizeof(tmp_pre_settlement_price));
  if (raw_pre_settlement_price != 0) {
    _internal_set_pre_settlement_price(from._internal_pre_settlement_price());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_settlement_price = from._internal_settlement_price();
  uint64_t raw_settlement_price;
  memcpy(&raw_settlement_price, &tmp_settlement_price, sizeof(tmp_settlement_price));
  if (raw_settlement_price != 0) {
    _internal_set_settlement_price(from._internal_settlement_price());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exchange_margin = from._internal_exchange_margin();
  uint64_t raw_exchange_margin;
  memcpy(&raw_exchange_margin, &tmp_exchange_margin, sizeof(tmp_exchange_margin));
  if (raw_exchange_margin != 0) {
    _internal_set_exchange_margin(from._internal_exchange_margin());
  }
  if (from._internal_comb_position() != 0) {
    _internal_set_comb_position(from._internal_comb_position());
  }
  if (from._internal_comb_long_frozen() != 0) {
    _internal_set_comb_long_frozen(from._internal_comb_long_frozen());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_date = from._internal_close_profit_by_date();
  uint64_t raw_close_profit_by_date;
  memcpy(&raw_close_profit_by_date, &tmp_close_profit_by_date, sizeof(tmp_close_profit_by_date));
  if (raw_close_profit_by_date != 0) {
    _internal_set_close_profit_by_date(from._internal_close_profit_by_date());
  }
  if (from._internal_comb_short_frozen() != 0) {
    _internal_set_comb_short_frozen(from._internal_comb_short_frozen());
  }
  if (from._internal_strike_frozen() != 0) {
    _internal_set_strike_frozen(from._internal_strike_frozen());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_close_profit_by_trade = from._internal_close_profit_by_trade();
  uint64_t raw_close_profit_by_trade;
  memcpy(&raw_close_profit_by_trade, &tmp_close_profit_by_trade, sizeof(tmp_close_profit_by_trade));
  if (raw_close_profit_by_trade != 0) {
    _internal_set_close_profit_by_trade(from._internal_close_profit_by_trade());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_strike_frozen_amount = from._internal_strike_frozen_amount();
  uint64_t raw_strike_frozen_amount;
  memcpy(&raw_strike_frozen_amount, &tmp_strike_frozen_amount, sizeof(tmp_strike_frozen_amount));
  if (raw_strike_frozen_amount != 0) {
    _internal_set_strike_frozen_amount(from._internal_strike_frozen_amount());
  }
  if (from._internal_abandon_frozen() != 0) {
    _internal_set_abandon_frozen(from._internal_abandon_frozen());
  }
  if (from._internal_yd_strike_frozen() != 0) {
    _internal_set_yd_strike_frozen(from._internal_yd_strike_frozen());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_cost_offset = from._internal_position_cost_offset();
  uint64_t raw_position_cost_offset;
  memcpy(&raw_position_cost_offset, &tmp_position_cost_offset, sizeof(tmp_position_cost_offset));
  if (raw_position_cost_offset != 0) {
    _internal_set_position_cost_offset(from._internal_position_cost_offset());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &reserve1_, lhs_arena,
      &other->reserve1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &broker_id_, lhs_arena,
      &other->broker_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &investor_id_, lhs_arena,
      &other->investor_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &posi_direction_, lhs_arena,
      &other->posi_direction_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hedge_flag_, lhs_arena,
      &other->hedge_flag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &position_date_, lhs_arena,
      &other->position_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &exchange_id_, lhs_arena,
      &other->exchange_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &instrument_id_, lhs_arena,
      &other->instrument_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &instrument_name_, lhs_arena,
      &other->instrument_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, position_cost_offset_)
      + sizeof(Position::position_cost_offset_)
      - PROTOBUF_FIELD_OFFSET(Position, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_account_2eproto_getter, &descriptor_table_account_2eproto_once,
      file_level_metadata_account_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AccountInfo* Arena::CreateMaybeMessage< ::AccountInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AccountInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Position* Arena::CreateMaybeMessage< ::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Position >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
